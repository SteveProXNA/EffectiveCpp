14 Item14
22-Nov-2013


Item 14: Think carefully about copying behavior in resource-managing classes.


Last item introduced RAII (Resource Acquisition Is Initialization) and auto_ptr and shared_ptr can be used for heap-based resources

Not all resources are heap-based thus auto_ptr and shared_ptr are inappropriate
You need to create your own-resource-managing classes here


C API to manipulate objects of type Mutex offering functions lock and unlock:


// lock mutex pointed to by pm
void lock(Mutex* pm);


// unlock the mutex
void unlock(Mutex* pm);



Create a class to manage locks
Class dictated by RAII principle that resources are acquired during construction and released during destruction


class Lock
{
public:
	explicit Lock(Mutex* pm) : mutextPtr(pm)
	{
		// acquire resource
		lock(mutexPtr);
	}

	~Lock()
	{
		// release resource
		unlock(mutexPtr);
	}

private:
	Mutex* mutexPtr;
}



// Define the mutex you need to use.
Mutex m;

// Create block to define critical section.
Lock m1(&m);

// Automatically unlock mutex end-of-block.



copy m1 to m2 - what should happen here?


RAII class author must confront: what should happen when an RAII object is copied?
Choose from the following possibilities:


Prohibit copying
Reference-count the underlying resource
Copy the underlying resource
Transfer ownership to the underlying resource


01.
Prohibit copying
In many cases, it makes no sense to allow RAII objects to be copied.
e.g. Lock no sense to have "copies" of synchronization primitives

When copying makes no sense for an RAII class, you should prohibit it
Item 6

class Lock : private Uncopyable
{
};



02.
Reference-count the underlying resource
Sometimes it's desirable to hold on to a resource until the last object using it has been destroyed
When that's the case, copying an RAII object should increment the count of the number of objects referring to the resource

This is the meaning of "copy" used by tr1::shared_ptr
RAII classes can implement reference-counting copying behavior by containing a tr1::shared_ptr data member

Change mutex_ptr from Mutex* to tr1::shared_ptr<Mutex>


Unfortunately, tr1::shared_ptr<T> default behavior is to delete what it points to when the reference count goes to zero
Not what we want!  Want to unlock mutex here not delete it


Fortunately tr1::shared_ptr allows specification of a "deleter" function to be called when reference count goes to zero
Not applicable to auto_ptr which ALWAYS deletes its pointer

Deleter function is second optional parameter to tr1::shared_ptr


class Lock2
{
public:
	explicit Lock2(Mutex2* pm) : mutexPtr(pm, unlock)
	{
		lock(mutexPtr.get());
	}

	~Lock2()
	{
	}
private:
	std::tr1::shared_ptr<Mutex2> mutexPtr;
};


In this class, Lock no longer declares a destructor: class dtor automatically invokes dtor of all class non-static data members
e.g. mutexPtr.  Now mutexPtr dtor will call tr1::shared_ptr deleter - unlock() when mutex reference count goes to zero


May want to add comment that didn't forget dtor but rely on compiler-generated dtor to auto invoke instance member dtors



03.
Copy the underlying resource
Perform DEEP copy and copy resource-managing object should also copy the resource it manages (wraps)

e.g. string (consists of pointers to heap memory where characters making up the string are stored)
String object copied, a copy is made of both the pointer and the memory it points to (DEEP copy)



04.
Transfer ownership to the underlying resource
Rarely you wish to make sure that only one RAII object refers to a raw resource and that when the RAII object is copied,
ownership of the resource is transferred from the copied object to the copying object

Item13 - meaning of "copy" for auto_ptr



The copying functions (copys constructor and copy assignment operator) may be generated by compilers
so unless the compiler-generated versions do what you want then you'll need to define behavior


REMEMBER
* Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the
  copying behavior of the RAII object

* Common RAII class copying behaviors are disallowing copying and performing reference counting,
  but other behaviors are possible